# 고급 프로젝트 협업 일지 (1팀 박은서)

## 오늘 할 일
* weekday 등 시계열 파생 변수를 활용한 추가 EDA 진행
* 클러스터링 가능한지 파생변수 만들어서 마스터 테이블 만들어보기
## 오늘 한 일
* weekday 등 시계열 파생 변수를 활용한 추가 EDA 진행
> 대부분 종헌님이 많이 진행해주셨고, 나는 클러스터링을 위한 파생변수를 만들면서 분석배경과 문제정의에 쓸만한 EDA 내용을 공유드렸다.
* 클러스터링 가능한지 파생변수 만들어서 마스터 테이블 만들어보기
> votes의 accounts 테이블들에서 다양한 파생변수를 생성하고, 합치는 과정에서 코드 리팩토링 등을 진행했다.
## 내일 할 일
* 파생변수 추가, 변수를 추가하면서 발생하는 결측치 보간
* 모델링 돌려보기
## Codes
```ruby
# 출석률 : 출석일수 / 계정 유지일수 << 로 하고싶었는데...
# 근데 탈퇴한 사람도 있잖아 그런 사람은 탈퇴일자 고려해야할텐데? : 문제는 user_id가 없음 withdraw에

# 출석일수 attendance_count
accounts_attendance['attendance_count'] = accounts_attendance['attendance_date_list'].apply(lambda x: len(json.loads(x)))

# 차단한 유저 수 block_count
accounts_blockrecord['block_count'] = accounts_blockrecord.groupby('user_id')['block_user_id'].transform('count')

# 친구 요청 전송횟수
accounts_friendrequest['request_count'] = accounts_friendrequest.groupby('send_user_id')['receive_user_id'].transform('count')


# 친구 요청 전송횟수 대비 수락 비율
# send_user_id별로 status가 'A'인 건수 계산
a_counts = accounts_friendrequest[accounts_friendrequest['status'] == 'A'].groupby('send_user_id')['status'].count()

# 3. request_count와 a_counts를 합쳐서 비율 계산
# (request_count는 각 행에 동일 값이 있으므로 'send_user_id'별로 한 번만 가져도 됨)
request_counts = accounts_friendrequest.groupby('send_user_id')['request_count'].first()

# 4. 비율 계산
ratio = (a_counts / request_counts).fillna(0)  # A 상태가 없는 경우 NaN을 0으로 처리

accounts_friendrequest['A_ratio'] = accounts_friendrequest['send_user_id'].map(ratio)
```
## Issues & Challenges
* 문제 : 클러스터링을 위해 파생변수를 생성하는 과정에서 결측치가 대량으로 발생하기도 하고, 커널이 끊기기도 했다. 하지만 차분하게 결측치가 발생한 원인에 대해 보간하는 방법을 생각해보고 코드 리팩토링도 하면서 문제를 해결했다.
## Notes & Ideas
* 아이디어 : 한가지에 몰두하다보면 다른 기초적인걸 잘 못 보게 되는데, 환기하는 시간을 중간에 한번씩 가져야겠다는 생각이 들었다.
## Reflection
* 좋았던 점 : 클러스터링 디벨롭에 최선을 다해서 몰두해보는 시간이어서 좋았다.
* 아쉬웠던 점 : 아쉬웠던 점은 없이 충분히 노력했던 하루였다.
